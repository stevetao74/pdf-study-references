-1. C++11新特性
    C++ primer plus(6) paragraph 18.1
    · 新增long long内置类型 支持64位
    · 支持{}初始化列表，包括内置类型和自定义的类类型
        1. 缩窄
            char chr = {8888}; //编译错误，禁止往更窄类型转换
    · 新的声明
        ...
    · explicit
        class plebe{
            explicit plebe(int num) {}; // convert int to plebe;
            explicit operator int() const {}; // convert plebe to int;
        };
    · 移动语义和右值引用 // 计算机移动文件，文件的存储位置实际不变，只是修改文件的描述信息，这叫移动语义
        class Useless{
            Useless(Useless && us){} // 编写移动语义，第一步，实现移动构造函数
            Useless operator=(Useless && us) {} // 这里是移动赋值函数
        }

        Useless one, three;
        Useless four(one + three); // 这里调用上面的移动构造函数， 编写移动语义，第二步，传入右值，调用移动构造函数
            // 即one+three 不会创建临时对象，再拷贝给four
    paragraph 18.2.5 强制移动
        Useless choices[10];
        Useless best;
        int pick;
        best = choices[pick]; // 拷贝赋值函数
            // static_cast<Useless &&> choices[pick] 静态编译期的强转成右值类型
            // C++11 提供std::move()函数，可以转换成右值类型
        
        实现移动语义
        1. 第一步，提供移动构造或者移动赋值函数
        2. 传入右值
        3. 即使提供了右值，但没有实现移动构造或移动赋值，就会使用复制构造或复制赋值函数
        4. 如果有一个构造函数，但没有提供复制构造函数或复制赋值函数，同样也不会触发移动语义


0. malloc

    malloc分配内存
        lt 128K 在data segment区域末尾的heap区 + size
            使用brk(void *) sbrk(int) 设置data segment结束位置， 分配可读写内存块
            sbrk(int size)
                size > 0 将program break向栈的方向移动size
                size = 0 返回当前program break的地址(void*)p，但不可读写
                    经由brk((int*)p + 1) 设置data segment结束位置，分配一个int大小可读写的内存块

        gt 128K mmap 在 堆和栈中间再找一块可用空间（TOP_DOWN | DOWN_TOP）

        strace可以看到brk sbrk mmap等函数调用输出日志

1. 智能指针
    C++ primer plus(6)
    paragraph 16.2 智能指针类模板
        template<class _Ty>
        class auto_ptr
        {	// wrap an object pointer to ensure destruction
            public:
                typedef _Ty element_type;

                explicit auto_ptr(_Ty * _Ptr = nullptr) noexcept : _Myptr(_Ptr)
                {	// construct from object pointer
                }
                ...
                ~auto_ptr() noexcept
                {	// destroy the object
                    delete _Myptr;
                }
                ...
                auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release())
                {	// construct by assuming pointer from _Right auto_ptr
                }
                ...
                _Ty * release() noexcept
                {	// return wrapped pointer and give up ownership
                    _Ty * _Tmp = _Myptr; // 先把原来的指针作为临时指针返回回去，付给新的quto_ptr
                    _Myptr = nullptr; // 再把原来的指针指向NULL; 后续再访问就会崩溃
                    return (_Tmp);
                }
                ...
            private:
	            _Ty * _Myptr;	// the wrapped object pointer
        }
        auto_ptr<string> auto_str( new string("123") ); // 只能使用explicit 构造
        auto_ptr<string> auto_str = new string("123") ; // 禁止使用implicit 构造
        auto_ptr<string> auto_str(&string("123") ) ; // 禁止构造非堆区内容

        0. 智能指针都有在生命周期结束的时候，自动析构掉指向的堆内容

        1. uniq_ptr 和auto_ptr 重新赋值左值都会夺取原有的控制权
            uniq_ptr会出现编译错误, 但允许临时右值赋值(C++11)
            auto_ptr对原来指针的访问会出现运行时错误，夺走控制权的时候被赋值NULL(被弃用的原因)

        2. shared_ptr指向的时候，会有引用计数的概念，允许同时多个指向

        3. uniq_ptr还多一个数组类型相较其他智能指针

        4. shared_ptr提供一个auto_ptr转型的构造函数

        auto_ptr<string> auto_str1 = auto_str; // 禁止多个智能指针指向同一个对象的地址
                // auto_ptr 会夺走原有的智能指针的控制权，导致原来的智能指针指向NULL，这时候访问该内容会出现崩溃
            // shared_ptr 每增加指向同一个对象的指针，引用计数就加一
            // uniq_ptr 只限定一个指向对象的指针，auto_ptr也有这个特性

        uniq_ptr<string> uniq_str(new (string("123")));
        uniq_ptr<string> uniq_str1 = uniq_str;
            //这里报错不会出现在运行时，编译期间就会报错，禁止多个uniq_ptr指向同一个对象地址

        uniq_ptr<string> demo(char *s)
        {
            uniq_ptr<string> tmp(new string(s));
            return tmp;
        }

        uniq_ptr<string> ps = demo("123"); // 这里从demo返回的uniq_ptr控制权被夺走，无法对临时智能指针访问，编译器允许这种写法
        // 进一步描述， 编译器允许uniq_ptr被一个临时右值赋值，因为临时右值没有机会再访问

        uniq_ptr<string> pt = std::move(ps) // std空间提供uniq_ptr给uniq_ptr赋值

        uniq_ptr<double[]> pt(new double(5)); // 配对使用delete[]; uniq_ptr比auto_ptr多一个数组类型


2. 设计模式
    设计模式：可复用面向对象软件的基础
    1. 创建型模式
        1. Abstract Factory (paragraph 3.1)
            客户->                              抽象工厂
                                                    抽象产品
                                                        具体工厂
                                                            具体产品
            不限定一定要有Abstract Factory, 可以直接定义一个具体工厂， 再定义继承这个具体工厂的子工厂；
            调用的时候定义一个方法，传入这个具体的子类的指针

            class MazeFactory{};
            Maze *MazeGame::CreateMaze (MazeFactory &factory){}

            class EnchantedMazeFactory : public MazeFactory{}
            class BoomedMazeFactory : public MazeFactory{}

            MazeGame mz;
            EnchantedMazeFactory enchFactory;
            BoomedMazeFactory boomFactory;
            mz.CrateMaze( enchFactory );
            mz.CrateMaze( boomFactory ); // 使用的时候，传入具体的子工厂

        2. Builder (paragraph 3.2) // 创建组件，添加到产品中
            new ConcreteBuilder
            new Director(ConcreteBuilder)
            construct: // 执行building
                ConcreteBuilder.BuildPart() // 处理请求，将部件添加到产品中
                ConcreteBuilder.GetResult() // 执行完后获取结果
                // buildpart构造代码 和 getresult表示代码分开

            1. 创建一个Buider
                class MazeBuilder{
                    public:
                        virtual void BuildMaze(){}
                        virtual void BuildRoom(){}
                        virtual void BuildDoor(){} // BuildPart
                        virtual Maze GetMaze(){} // GetResult
                    protected:
                        MazeBuilder(){}
                };

            2. Director
                Maze *MazeGame::CreateMaze (MazeBuilder &builder)
                {
                    builder.BuildMaze();
                    builder.BuildRoom();
                    builder.BuildDoor(); // building

                    return builder.GetMaze(); // GetResult
                }

            这和Abstartct Factory直接生成产品不一样, builder是在Director的控制下一步步的构造产品的，先完成build，再取回产品 
            Abstract Factory着重多个系列产品， Builder类可以差别很大
            Abstract Factory是立即返回结果的，Builder是在完成之后，由Director自己取的

        3. Factory Method (paragraph 3.3)
            Product                                     Creator
                                                            FactoryMethod()
                                                                return new Product;
            ConcreteProduct                             ConcreteCreator
                                                            FactoryMethod()
                                                                return new ConcreteProduct;

            Creator声明工厂方法，返回一个Product；ConcreteCreator重定义工厂方法，返回ConcreteProduct

            1.  定义一个Creator
                class MazeGame{
                    public:
                        Maze* CreateMaze();

                        // Factory Method
                        virtual Maze* MakeMaze(){ return new Maze;}
                        virtual Maze* MakeRoom(){ return new Room;}
                        virtual Maze* MakeWall(){ return new Wall;}
                        virtual Maze* MakeDoor(){ return new Door;}
                };

            2. 使用
                Maze* MazeGame::CreateMaze(){
                    Maze *aMaze = MakeMaze();
                    Room *r1 = MakeRoom();
                    Door *d1 = MakeDoor();

                    amze->AddRoom(r1);

                    return aMaze;
                }

            3. Abstract Factory经常用Factory Method来实现
                前者注重系列产品种类，实现细节却是Creator-ConcreteCreator::FactoryMethod{ return ConcreteProduct;}

            4. Factory Method经常在Template Method中被调用

            5. Prototypes不需要创建Ctreator子类, 但是通常要求一个针对Product类的Initialize操作。Creator使用Initialize来初始化对象。Factory不需要

        3. Prototypes (paragraph 3.4)

            client                                      Prototype
                                                            Clone()
                                                        ConcretePrototype1      ConcretePrototype2
                                                            clone()                 clone()
                                                                return copy of self     return copy of self

            

    2. 结构型模式 // 处理类或对象的组合
    3. 行为模式


3. 线程并发（同步互斥）

4. select/epoll

5. 消息队列

6. 性能调优/linux 命令