1. 内存非法访问
    1. 使用valgrind 排查overlap问题
        memcpy处崩溃，经valgrind排查有overlap情况，发现memcpy的源地址和目标地址发生重叠，原因是RPC传过来的地址是一个常量数值，导致访问该地址出现非法访问
    2. 调用外部dll时，内存被释放，使用时出现非法访问
        出现非法访问时，和上面类似，但这个地址跟RPC无关，经过排查日志，发现该处地址被外部dll HeapFree释放掉。

2. 运行时栈被破坏(EBP, ESP)
    调用函数栈上的一个变量地址传入到被调用函数里，因为ZeroMemory的大小不对，导致EIP被改变，函数调用栈无法正常显示。

3. 调用约定的错误
    stdcall函数调用_cdecall
    和上面类似，破坏寄存器的内容

4. 其他的就是调用wine内部实现函数的逻辑问题
    使用winedbg调试，直接continue没有崩溃堆栈，在进入某个模块前，用si进入模块，ni快速跳过，可以看到崩溃汇编地址，记录下来，在IDA中继续分析
    查看反汇编代码，分析走到该位置的逻辑，分析错误原因（主要是wine内部的实现）